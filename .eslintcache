[{"/Users/kietho/Repos/playground/3d-web/src/reportWebVitals.js":"1","/Users/kietho/Repos/playground/3d-web/src/App.js":"2","/Users/kietho/Repos/playground/3d-web/src/index.js":"3","/Users/kietho/Repos/playground/3d-web/src/Web3D/TemplateCanvas.js":"4","/Users/kietho/Repos/playground/3d-web/src/Web3D/ShapeEditor.js":"5"},{"size":362,"mtime":1606710309750,"results":"6","hashOfConfig":"7"},{"size":194,"mtime":1607740182066,"results":"8","hashOfConfig":"7"},{"size":499,"mtime":1606710620718,"results":"9","hashOfConfig":"7"},{"size":2363,"mtime":1607740207145,"results":"10","hashOfConfig":"7"},{"size":3239,"mtime":1607712128751,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"1uqnidv",{"filePath":"15","messages":"16","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"21","messages":"22","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"23","usedDeprecatedRules":"14"},"/Users/kietho/Repos/playground/3d-web/src/reportWebVitals.js",[],["24","25"],"/Users/kietho/Repos/playground/3d-web/src/App.js",[],"/Users/kietho/Repos/playground/3d-web/src/index.js",[],"/Users/kietho/Repos/playground/3d-web/src/Web3D/TemplateCanvas.js",[],"/Users/kietho/Repos/playground/3d-web/src/Web3D/ShapeEditor.js",["26"],"import * as THREE from 'three';\nimport  React from \"react\";\nimport TemplateCanvas from './TemplateCanvas'\n\nclass ShapeEditor extends TemplateCanvas {\n    // Create class variables\n    scene = null\n    renderer = null\n    camera = null\n    pickedObject = null\n\n    colors = {\n        lightPink: 0xF5BFD2,\n        darkPink: 0xff26ac\n    }\n\n    render(){   \n        // This is required to to attach the Three.js ref to component\n        return <div ref={ref => (this.mount = ref)}/> \n    }\n\n    addCube(x = 0, y = 0, z = 0){\n        const scene = this.scene\n        const renderer = this.renderer\n        const camera = this.camera\n\n        const geometry = new THREE.BoxGeometry()\n        const material = new THREE.MeshBasicMaterial( { color: this.colors.lightPink } )\n        const cube = new THREE.Mesh( geometry, material )\n\n        cube.position.set(x,y,z)\n        scene.add( cube )\n        renderer.render( scene, camera );\n    }\n\n\n    onMouseClick = () => {\n        const scene = this.scene\n        const raycaster = this.raycaster\n\n        if (this.pickedObject){\n            scene.remove(this.pickedObject)\n            this.pickedObject = null\n        } else {\n            const objectPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1))\n            var intersect = raycaster.ray.intersectPlane(objectPlane);\n            this.addCube(intersect.x, intersect.y, intersect.z)\n        }\n    }\n\n\n    renderScene = () => {\n        const renderer = this.renderer\n        const scene = this.scene\n        const camera = this.camera\n        const raycaster = this.raycaster\n        const mouse = this.mouse\n\n        // update the picking ray with the camera and mouse position\n        raycaster.setFromCamera( mouse, camera );\n    \n        // Calculate intersections\n        const checkIntersects = () => {\n            var intersects = raycaster.intersectObjects( scene.children );\n            if ( intersects.length > 0 ) {\n                if ( intersects[0].object != this.pickedObject ){\n                    // restore previous intersection object (if it exists) to its original color\n                    if ( this.pickedObject )\n                        this.pickedObject.material.color.setHex( this.pickedObject.currentHex );\n                        this.pickedObject = intersects[ 0 ].object;\n                        this.pickedObject.currentHex = this.pickedObject.material.color.getHex();\n                        this.pickedObject.material.color.setHex( this.colors.darkPink );\n                }\n            } else {\n                // restore previous intersection object (if it exists) to its original color\n                if ( this.pickedObject ){\n                    this.pickedObject.material.color.setHex( this.pickedObject.currentHex )\n                }\n                this.pickedObject = null;\n            }\n        }\n\n        const rotateCubes = () => {\n            scene.children.forEach(child => {\n                child.rotation.x += 0.01\n                child.rotation.y += 0.01\n            });\n        }\n\n        // Call animating functions\n        rotateCubes()\n        checkIntersects()\n        renderer.render( scene, camera )\n        window.requestAnimationFrame(this.renderScene)\n    }\n}\n\nexport default ShapeEditor",{"ruleId":"27","replacedBy":"28"},{"ruleId":"29","replacedBy":"30"},{"ruleId":"31","severity":1,"message":"32","line":66,"column":43,"nodeType":"33","messageId":"34","endLine":66,"endColumn":45},"no-native-reassign",["35"],"no-negated-in-lhs",["36"],"eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","no-global-assign","no-unsafe-negation"]